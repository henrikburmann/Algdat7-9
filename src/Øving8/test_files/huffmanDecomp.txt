§TekstsÃ¸k, Datakompresjon

Helge Hafting

Institutt for datateknologi og informatikk

SekDı 1 `	ÿ
ö  â€¢ Fritwè i dokumenter, nettsiderSølignende8øatabaserXöSÃ¸kemotorã etter repeterte strenger forHökompresjonmóDNA-matching
î  Tekst: rabarbra ö(lengde n)uÿSqûord:  ÿm ûkyv s%öet langs tXöen, se om úpasservò  â€¢ tegn somê, vises med fet skrift/
ôfÃ¸rste feil%úkursivP
âdobbeltlÃ¸kke for n-m posisjonaüog mwòi sÃ¸keordet.
Õ  Hele greia, O\left(n\cdot m\right),\Omegaÿrÿ
<ıForQû  | rÿa
ÿb
	ÿr	ÿrş
-	ÿ+'ú
    0ÿ Kı  |ÿ 
ô


  ForsÃ¸k-ÿb7	ÿrKÿ
|ÿ-ÿ+'ÿ
|ÿ1|ÿ }ÿbnÿ ô


  ForsÃ¸k(ÿb2	ÿrFÿ
|ÿ-ÿ+'ÿ
wÿ2|ÿ }ÿ Uÿ ô


  ForsÃ¸k#ÿb-	ÿrAÿ
|ÿ-ÿ+'ÿ
rÿ3wÿ }ÿ ÿbxğ   |


  ForsÃ¸kÿb(	ÿr<ÿ
|ÿ-ÿ+'ÿ
mÿ4rÿ xÿ 
ÿb}ô


  ForsÃ¸kÿ (ÿa-	ÿb7
ÿ
|ÿ-ÿ+'ÿ
|ÿ5ş |ÿbdõ

  ForsÃ¸kz
ÿ %ÿa*	ÿb4ÿ-	ÿ+'ÿ
~ÿ0~ÿ ı  |ÿ 
ÿ
/ÿ1/ÿ 4!ÿ
^ÿ2/ÿ hÿ
sÿ3/ÿ hÿ
nÿ4/ÿ hÿ
}ÿ5/ÿ hÿ
Ó  â€¢ Se pÃ¥ siste tegn i sÃ¸keteksten fÃ¸rst/åHvis det ikke passer, flytt7ğsÃ¥ langt vi kanrú   | rÿa
ÿb
	ÿr	ÿrÿ
,ÿ-ÿ+'ÿ
^ş 0Iı  |vÿ 
ÿ
.ÿ1ÿb8ÿ
\ÿ2Mÿbkÿ
\ÿ3{ÿ kĞ


  â€¢ Hvis det passer, se pÃ¥ nestsiste osv.
ÿ 4
Átegnet ikke fins i sÃ¸keteksten, kan vi flytte m steg
    frem:Mú   | mÿe
ÿt
	ÿoÿrÿi	ÿt-ÿs(ÿiAûn
  -ÿ+Eú
    0mı  |!ÿ|#ÿ
Jÿ11ÿsc&ÿ
sÿ2{+ÿ ^¾


  â€¢ Hvis tegnet fins til venstre i sÃ¸keordet, kan vi flytte ÿ
|æsÃ¥ det passer med teksteneúVi har=êen tabell for hvor myeWıkan[ÿ
6÷I praksis6òele alfabetet,Fçde fleste tegn
    gir etUä pÃ¥ m. (Regel om Â«upassend3ıÂ»)yÿTlÒen lager vi ved Ã¥ pre-prosessere sÃ¸keteksten<	òegn som fins i$ö, gir kort>úflytt
tò  â€“ En Â«sÂ»5óiste posisjon6ÿf.ë pÃ¥ m-1, fordi ordetAû  staXÿ #ÿÂHş

Xè¢ \Omega\left(n/m\right)Bì sÃ¸ket. Mye bedre!
ÿ ;éHvis tegnet ikke fins i8Úeksten, kan vi flytte m steg
    frem,Mù  â€“ hOêmismatch var pÃ¥ sistefÿ Zÿ
9	ımed8
øpÃ¥ nest8êkan vi flytte m-1 stegy
ÿv@ÿnDÿ,9ÿrDım-2=ú osv.
Cü | mÿe
ÿt
	ÿoÿrÿi	ÿt-ÿs(ÿiAûn
  -ÿ+Eú
    0|ÿmh	ÿnr	ÿ +ÿ
Jÿ16ÿmY0Í


  â€¢ Vi trenger altsÃ¥ en todimensjonal tabell:3Ù  â€“ En indeks er det upassende tegnet+
÷Den andre2şen4üposi^ïen i sÃ¸ketekstend
ûVerdi ücell7Şhvor langt vi kan flytte fremover
ü  Fo/ÿek
ş pkÿ )ìt tegn x i alfabetet#ğ   let mot startIú fra p,
êhvis vi finner x etter~üteg,T
îsett Tab[p][x] = iDüikkeI	ÿ,.
û=p+1
ÿ zı| rÿe
ÿn	ÿe
ü
  -ÿ+&ÿ
Yÿ0Gÿ oÿ 
ÿ
,ÿ1	ÿe1ÿ
Xÿ2Iÿebÿ
mÿ uÿ g¹


  â€¢ 0,1: NÃ¥r siste posisjon treffer Â«nÂ», kan vi bare flytte ettsüstegOò2: Feil i fÃ¸rQÿ
r×  â€“ Regel om Â«upassende tegnÂ» lar ossiû hakkeÿR@
ÿp?ùendelseBÿf=şto<ü her@ıÂ«n)ÿp{÷t, og Â«eéoverlapper med seg selvyêVi slÃ¥r opp bÃ¥de Â«uHønde tegnEÿg[ünde ûlseÂ»gĞ
    bruker regelen som gir det lengste hoppet.
ÿ |ûTabel2úfor Â«bÿ
*ã  â€“ index er hvor mange tegnÿp:ÿt-
õverdien i caÿe8ílangt vi kan flyttec½â€¢ Lages ved Ã¥ prÃ¸ve ut om sÃ¸keteksten overlapper med seg selv
}
åofte gjÃ¸r den ikke det, ogzïfÃ¥r lange hopp!
ö  â€¢ Hvis%ÿssïr etter Â«aaaÂ» i
óaaaâ€¦Â», harRàdessverre O\left(n\cdot m\right)^û  â€“XÎordet passer overalt, de samme a-ene sjekkes flere@ø  gangerNáâ€¢ Galil fant en mÃ¥te Ã¥ unng÷Ã¸dvendigYúnligniBÿ:CÑ  â€“ NÃ¥r vi flytter sÃ¸keordet kortere enn deúlen av$ÿ
Gÿ @çallerede har sjekket, trepø vi ikkeÿ :
îoverlappende omrÃ¥z÷omigjen.
`İâ€“ Korte flytt skjer fordi sÃ¸keor5èdelvis matcher seg selv.jÿHêdet ikke hadde passet,şviaôet lenger.

=ùTekstenHı| .ÿOÿlÿa
ÿ.-ş| ÿ
HõMismatch O/,ÿ 	ÿl@ÿlT	ÿ -ÿ|1ÿ
JôNytt forsÃ¸kF
ÿ U)ÿ|Kİ

  â€¢ Programmet trenger ikke sjeîden oransje regionúmigjenCßDermed: O\left(n\right) og \Omegaş/mîfor
    tekstsÃ¸k
ÿ QûBoyer?íMoore sin artikkel:%ã  http://www.cs.utexas.edu/~m4ç/publications/fstrpos.pdfc÷WikipediaQøs://en.wû.org/ù/Boyer_[è_string_search_algorithmZäAnimasjon (Fyll ut, og velg Gş-MGÿ)uò Trenger java
BÙ  http://www.cs.pitt.edu/~kirk/cs1501/adïtions/String.html@êâ€¢ Demonstrasjon pÃ¥ rï sin nettside:


júutexaslùusers/m5ó/best-ideas/skÜ-searching/fstrpos-example.html

Sekyí2 Mer om datakompreÿ
í  â€¢ Enkleste formÿ +ÿ (ó serie repeti^åer erstattes med et antall:^÷  â€“ ABIâBBBCDEFFFGH \rightarrow AB12I3ú3FGH

vãI praksis litt mer kompliserte
èdet kan jo vÃ¦re sifre işvi4ùrimerer5
Õser vanligvis pÃ¥ Â«bytesÂ», ikke Â«tekstÂ»j
ÜmÃ¥ kunne skille mellom data og metaş

içâ€¢ Eks., bruker negativ hä for ukomprimerte sekvenser:q
ıABIéBBBCDEFFFGH \rightarrow.ä  [-2]AB[12]I[3]B[-3]CDE[3]FşGHV
ã25 byte ble redusert til 16

}æâ€¢ Kan ikke komprimere AB
ıâ€¦-ÿ
1	îLeser gjennom filaKòInput kopieresjúoutputlèHvis en lang nok sekvens|ùmer omiXÿ:lã  â€“ dropp den, skriv hellerF÷referansejÿ 9ëformat: repeter X tegFğom vi har sett Yö tidligere{Çâ€¢ Hjelper hvis sekvensen er lenger enn en slik referans>	ÛSÃ¸ker bakover i et sirkulÃ¦rt bufferkÏOutput kan komprimeres videre med Huffman-koding
ÿ k÷MÃ¥ vÃ¦re=ıaktô  â€“ ellersZóvi ikke referXîtil korte strenger8
ïf.eks. 2â€“3 bytem¾Ã… Â«seÂ» langt bakover i datastrÃ¸mmen, gir stÃ¸rre sjanse for Ã¥dìfinne repetisjoner.
~
æmen ogsÃ¥ lenger kjÃ¸retid$
÷pÃ¥virkerWûmatetú refernøne vÃ¥reWÚ  âˆ— 1 byte kan peke 255 tegn bakover,ÿ2,ø65â€¯5361ÿ3]ó16â€¯777â€¯21hõâ€¢ I blanteívi ikke komprimere
^Ùâ€“ MÃ¥ derfor ogsÃ¥ ha en mÃ¥te Ã¥ si:-
ıHerFómer X bytes uV	ùte data[
íSlik informasjon taeùplass!
ğ  â€¢ Vurdering:ÿ Dçkal dette vÃ¦re en del av
æstÃ¸rre ukomprimert blokk?B
İEvt. bakover-ref + header for korteBş

?÷¢ Det vi a	Ûer mÃ¥ altsÃ¥ vÃ¦re lenger enn samletúde
   fş:
Næ  â€“ en bakover-referanse
úheader4û en uv	ùt blokkGùâ€¢ Vi 	Øer ikke svÃ¦rt korte strenger, det hjelp(ş!
ÿ JòEksempeltekst:÷  Problem?ÿpø. Alltid
ï!
Dette er dagens-ÿ.A	ît er
Ã¥ komprimereQúatisk vÿ.uôâ€¢ Eksempelğ med avstander:
%ÿ Y	ùr,^{10}rêer^{20}. Alltid p^{30},å!
^{40}Dette er d^{50}agensA÷^{60}lem._Ş^{70}emet er
Ã¥ ^{80}komprimere^{9y
¶at^{100}isk tekst.^{110}

  â€¢ 110 tegn, inkludert linjeskift og blanke.
ÿ 7øEksempelSñ med avstander:%í  Problemer,^{10} pì^{20}. Alltid p^{30},å!
^{40}Dette er d^{50}agensA÷^{60}lem._Ş^{70}emet er
Ã¥ ^{80}komprimere^{9y
ßat^{100}isk tekst.^{110}

  â€¢ K7ıt:
ú  [12]gºemer, p[-11,8][8]. Alltid[-18,10][17]!
Dette er dagens[-27,7][2]. [-65;ô17]t er
Ã¥ kpüe[-3æ2]atisk tekst.

  â€¢ FÃ¸r.
óing, 110 tegn$	åMed 1 byte per tallkode, 84)ò
    Vi sparteCú-84=26Iõ, eller 23%wïse ogsÃ¥ Lz-demo
ÿ qúFor hvk»egnposisjon i input, mÃ¥ vi sÃ¸ke etter lengste match
    i bufferet.W	øil med nXô, sirkulÃ¦rt,ÿ ôstÃ¸rrelse m;	şTe^êalle posisjoner, i verxçfall O\left(nm^{2}\right)|ÅI praksis gÃ¥r det bedre, sÃ¦rlig hvis data varierer en delCİKan bruke Boyer-Moore tekstsÃ¸k forTô kjÃ¸retid.
ÿ BåLempel og Ziv sin artikkel:)Ãhttp://www.cs.duke.edu/courses/spring03/cps296.5/papers/ziv_l[Ò_1977_universal_algorithm.pdf

  â€¢ Wikipediauü    xøs://en.wû.org/ş/LZğ\%E2\%80\%93Ziv
ÿ RæLZ leser input, og skriveraìâ€“ bakover-referansûsekveê med ukomprimerte tegngÿuõ telles oppuÿk9÷es videreQÿ
gñHuffmannkoding
ÿ XæLigner LZ. Teoretisk sammeRõesjon. LettS÷Ã¥ speedexÿ.E	õeser ett ogütegnbüByggßn ordliste (dictionary) underveisN÷  â€“ tiljàbegynne med, alle 1-byte Â«ordÂ»êFinn et (lengst mulig)où, skrivzúnummer&ômed fÃ¦rrestsÿm0ù bits!)Tğ  â€“ lagre nyttpø = detteZñet + neste tegn7íâ€¢ Kompresjon hvis*õne blir lenRõenn numrene6ÒLZW+Huffman \rightarrowDeflate (brukt i zip)

líSe eksempel Â«lzwÂ»ÿ
!	ıLZWbî  â€“ leser input,
ìbygger en dictionaryîskriver Â«ordnumredÿ üNoenâÂ» forekommer oftere enn andre0ÛProgrammet finner antall (frekvenser)Iù ulike rÿ,qß  â€“ skriver Huffmankoder i stedVşor5	ÿ
4	ùord somYåekommer ofte, fÃ¥r kortere Kÿ
î  â€¢ Komprimerer 6ïenn LZ-algoritmeneì1. run-length coding}Ô2. Burrows-Wheeler transformasjon (hoveddel)rğ3. Move-To-Front.ıMFT)ÿ4qú igjenwô5. Huffmannkÿ
ù  â€¢ Hsåen av BZ2 (blokksorteringeneÌâ€¢ Dette steget komprimerer ikke selv, men transforùen
    Vò (typisk 900kBY	ÿT1ùrepeterkêekvenser (som ord) til"
ÿ
ZütegnJÿR<	çtegn er lettere Ã¥ komprieø videre!7ñTransformasjone9îreversibel (for de@	ûing)
ÿ xëBWT pÃ¥ ordet Â«referõâ—Â». Tegnÿâû mark ø sluttenGò
  Rotasjoner õSortert
  -ÿ
,ÿrs	ş€¢<ÿe
ÿr!ıâ€¢$	ÿ !ÿrşefBÿâ"
ÿ !ÿâ5ÿ
2ÿâD	ÿ ÿ
BÿeD
ü    nÿâzÿ
Sÿ 1ÿf#	ÿ
Bÿeuÿ ÿ
Bÿexÿ sÿ
tÿ cÿâÿrBÿfD
ü     ür


Ô BWT er siste kolonne med tegn fra sortert l#î, Â«rfrreâ€¢eeerÂ»IëNÃ¥ har vi mange likeFéved siden av hverandre,:è  â€“ lettere Ã¥ komprimëmed run-length coding5
ÜSe ogsÃ¥ bw brukt pÃ¥ diverse filer
Ö  â€¢ Hvordan gÃ¥ fra Â«rfrreâ€¢eeerÂ» tilûefereıÂ»?=úVet at4äer siste kolonne i sortert lÿ
}àLista bestod av ulike rotasjoner÷samme ordu÷  â€“ all[	ñr inneholder de/útegnenhõvar sortertL
úfÃ¸rstO	ò mÃ¥ altsÃ¥ haQÿ,Aÿa-ğÂ«eeeefrrrrâ€¢Â»{óVi har nÃ¥ toför, i ei li{ñover rotasjoner[
ıkanñere sidelengs, nÿs9ÿkNï blir fÃ¸rste, ogAÿ ÿ ûandre[
Údette er fortsatt en del av lÃ¸sningen0
õsorterer vi<ü, haı tol	økolonnenkùsÃ¥ kan:ôlegge pÃ¥ si.ü igjmşvi]únÃ¥ trT	òr. Repeter til%ûalle!mçâ€¢ Riktig rad er den somLùÂ«â€¢Â»|úplass
ÿ ?àHvordan gÃ¥ fra Â«rfrreâ€¢eeerÂ»xøÂ«refereıÂ»?|üLegg!ÿs_ìRotere mot hÃ¸yreSorğ

   re ef fe erÿrüâ€¢r"ÿfÿ  ü refF	ÿrÿ \ÿr$ÿâÿ zÿrlÿe
ÿ oÿelÿâ=ÿ }ìâ€¢ \Longleftarrow D[ÿrUÿ Kÿe$ÿâÿ iÿeH	ÿâÿ ^ÿelÿr!û rer
	ÿ eÜ Komprimerer ikke data, men forbered5ÿ -÷Initialis/Àen tabell med alle byte-verdier. t[0]=0,
    t[1]=1, t[2]=2, â€¦VıLesNûtt ogòtegn fra input}ö  â€“ finnüet i|éen, skriv index til out8şlyVöet vi fant)ófÃ¸rste plassS÷ (move to{ø  front)Qóâ€¢ input: caşcbÿaÿ
1üinn: ô ut:21000012ş21ö

  tabellJô0: aca....cbÿajú1: bacÿc&ÿbkÿ
jû2: cb:ÿbFÿ.ÿ
`ú3: ddd`ÿdÿ. 
Ùâ€¢ Alle repeterte tegn blir til nuller+şKo"ÿr,òende sekvenser3÷smÃ¥ tall]ÚLett Ã¥ gÃ¥ andre veien ved utpakking
ÿ eùEksempeCö    inn:caşcbúaaaabb ô ut:21000012ş00ş10R	ÿ
HõFrekv. fÃ¸rWÿ|ÿ ÷etter
  -ÿ+ÿ-ÿ
}ÿaû    9	ÿ|Yÿ0ş14{ÿb&ÿ1<ş 3LÿcLÿ2Lÿ2&Ø

  â€¢ FÃ¸r: like mange Â«aÂ» som Â«bÂ»(çEtter: overvekt av Â«0Â»,+êkan fÃ¥ kortere kode.
ÿ iïBurrows-Wheeler s+ør sÃ¥ vi?ìr mange repetisjoner?â  â€“ 900â€¯kB blokkstÃ¸rrelseaèMove-to-front gjÃ¸r ulikPô om til null^Íâ€¢ Deretter fungerer run-length coding veldig bra!s÷Huffmannk"êav det som blir igjen
ÿ 2ÿk1	ëei fil, bruker samme Pøfor hele"ÿatÿE1õ kan bestÃ¥wŞulike deler (f.eks. norsk+engelsk)?ù  â€“ U,ıhar<ï bokstavfordeling/
òDe komprimerestü medsòHuffman-trÃ¦r
â  â€¢ Noen forskere mener dataNäesjon og AI er samme problem|
ñAI: det kortest"şgr,ót som oppfÃ¸rAòeg intelligentCúâ€¢ Ã…$Âdage repeterte mÃ¸nstre (kan nyttes for kompresjon)
    kreverXÿsXÿMö gir bedreDÿ
,ÔDesimalene i \pi er et vanskelig datasett Ã¥?ëimere. (mye
    variaSú) Men:YÕ  â€“ vi kjenner rekkeutviklinger som generû \pi.8
ŞEt program med endelig lengde, kan;	û hele^÷a. \inftyò   kompresjon![êâ€¢ Ei zipfil er vanskYşÃ¥-ãimere, selv om det fins bedreWÿkT	ü ennMÿ
oëâ€“ Hvis vi pakker utlúa, kanÿke	ÿ Sø med bz2D
ìÃ… oppdage at noe erfÿ-;	÷t, og der<ókan behandlesEâ  slik, krever intelligensâ€¦
